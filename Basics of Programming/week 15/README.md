#### 任务描述

请你设计C/C++程序进行集合计算。要求先用链表存储两个正整数集合A和B（从键盘输入集合的元素，以-1结束输入），然后计算A和B的交集、并集与差集A-B，再输出计算结果，结果集合中的元素按升序排序，最后删除所有动态变量。

#### 输入格式

两行
第一行：若干个正整数（代表集合A，最后输入一个 -1）
第二行：若干个正整数（代表集合B，最后输入一个 -1）

#### 输出格式

三行
第一行：若干个正整数（代表交集A∩B，正整数之间用空格分隔，若集合非空，结尾同样输出空格）
第二行：若干个正整数（代表并集A∪B，正整数之间用空格分隔，若集合非空，结尾同样输出空格）
第三行：若干个正整数（代表差集A-B，正整数之间用空格分隔，若集合非空，结尾同样输出空格）

#### 样例

输入：
1 2 3 5 7 -1
1 2 3 4 5 6 -1
预期输出：
1 2 3 5
1 2 3 4 5 6 7
7

#### 任务描述

请你设计C/C++程序反转一个单向链表，即，将链表中节点的前后关系颠倒，头节点成为尾节点，尾节点成为头节点，第二个节点成为倒数第二个节点，以此类推。

#### 输入格式（1行）

若干个整数（存储在单向链表中），最后输入一个 -1

#### 输出格式（1行）

若干个整数（存储在单向链表中，顺序与输入顺序相反）

#### 样例

输入：
1 2 3 4 -1
预期输出：
4 3 2 1

#### 任务描述

B站会根据视频的“综合得分”，对各个分区的视频进行排行，以便将得分高的一些优质视频放到各个分区的视频排行榜中。请你用学过的C/C++结构体和单链表，设计一个简单的模拟系统，对各分区视频进行排行。具体要求如下：
(1) 一条视频访问信息用下面的结构类型描述：
struct VideoNode
{
    int id;            //视频的id，每个视频都有一个唯一的id
    char label[20];        //视频所属的分区，表示视频的类别
    int visit;            //该视频的浏览量
    int liked;            //视频获得的点赞数
    int collection;        //视频获得的收藏数
    int coins;            //视频获得的投币数
    int score;            //视频的综合得分
    VideoNode* next;    //指向下一个视频
};
(2) 输入的多条视频访问信息存储于一个单向链表中。
(3) 输入信息时，先输入一个实时请求标志t：
如果t是0，表示该请求是新增一条用户的视频访问信息（对应节点的浏览量要+1，如果节点尚不存在，则需要新增一个节点），之后会输入4个非负整数，分别代表视频的id、是否对该视频点赞、是否对该视频收藏、以及对该视频的投币数，最后输入一个单词label，代表视频所属的分区（不区分大小写）。一个视频只对应一个分区，一个分区有一个或多个视频。
如果t是1，表示该请求是要统计并输出某分区的视频排行，之后会输入一个单词label，代表要统计并输出排行的分区。
(4) 一条视频的综合得分score = 浏览量*1 + 点赞数*2 + 收藏数*3 + 投币数*4。

#### 输入格式（若干行）

第一行，一个正整数 q（代表请求的次数）
第2~q+1行，一个0或1，[一个非负整数，一个0或1，一个0或1，一个非负整数]，一个单词（代表q次请求的具体内容，中括号中的内容可能没有）

#### 输出格式（若干行）

如果请求类型t是0，则不需要输出。
如果请求类型t是1，则根据label，按综合得分score从大到小输出该分区的视频id和score，如果得分相同，则先输出id小的视频，每个视频占一行。
【你在离线调试的时候，可以先输出整个链表，每条视频占一行，每行输出id和score】

#### 样例1

输入：
3
0 1 1 0 0 Food
0 4 0 1 0 Technology
0 6 1 1 3 Music
预期输出：

#### 样例2

输入：
9
0 1 1 0 0 Food
0 7 0 1 0 Game
0 3 1 0 1 Food

1 Food
0 4 0 1 0 Game
0 5 1 0 2 Fun
0 6 1 1 3 Music
0 2 0 1 0 Game
1 Game
预期输出：
3 7
1 3
2 4
7 4

0. （单向链表中的环）判断一个单向链表中是否有环（即最后一个节点的next指针是否指向了链表中的某个节点），并对无环的非空单向链表建立一个环（从链表最后一个节点指向第M个节点，其中，M可以是1、2、3、...），操作成功，返回true，否则（链表空），返回false。函数原型分别为：bool HasLoop(Node *head);及bool CreateLoop(Node *head, int m);



0. （找交点）实现findFirstCross函数：查找两个无环单向链表首个重合节点的位置，若无重合返回NULL。查找函数原型和链表的节点类型为“const Node *findFirstCross(const Node *headA, const Node *headB);”。【提示：先创建两根链表，调用一次查找函数；然后“制造”交叉点，再调用一次查找函数】
